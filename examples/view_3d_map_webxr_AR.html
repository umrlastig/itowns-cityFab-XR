<!DOCTYPE html>
<html>

<head>
    <title>iTowns XR Example</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="css/example.css">
    <!-- Import iTowns -->
    <script src="../dist/itowns.js"></script>
    <script src="../dist/debug.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="viewerDiv"></div>
    <div id="description">
        <p><b>GNSS master</b></p>
        <ul id="info"></ul>
    </div>
    <script type="module">

        import * as THREE from 'three';
        import { XRButton } from 'three/addons/webxr/XRButton.js';
        import { createText } from 'three/addons/webxr/Text2D.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        // import placeObjectOnGround from './../../packages/Main/src/Utils/placeObjectOnGround.js';

        // -------------------- Config & Constants --------------------
        const DEFAULT_POSITION = {
            gouaix: { longitude: 3.294129, latitude: 48.483560 },
            mlv: { longitude: 2.587640, latitude: 48.840638 },
            smd: { longitude: 2.4223264, latitude: 48.8447549 },
            loos: { longitude: 2.7922434, latitude: 50.4577818 },
            pessac: { longitude: -0.618932, latitude: 44.794517 },
        };

        let rotationGlobal = { pitch: 0, heading: 0, roll: 0 };

        // Utility functions are now imported from ./js/utils.js

        // -------------------- Main Logic --------------------
        async function main() {
            let TCP_status = "Disconnected";
            let geo = DEFAULT_POSITION.pessac;
            let rotation = { pitch: 0, heading: 0, roll: 0 };
            try {
                // const pos = await getCurrentPosition();
                const pos = await fetch('http://localhost:8085/').then(r => r.json());
                geo = { longitude: pos.longitude, latitude: pos.latitude };
                rotation = { pitch: pos.pitch, heading: pos.heading };
                rotationGlobal = rotation;
                TCP_status = "Connected";
            } catch (e) {
                console.warn("Geolocation error, using default position.", e);
            }

            if (geo.longitude == undefined) {
                geo = DEFAULT_POSITION.mlv;
                TCP_status = "Disconnected";
            }

            // ---- Initialize iTowns view ----
            const placement = {
                coord: new itowns.Coordinates('EPSG:4326', geo.longitude, geo.latitude),
                range: 10,
                tilt: 5,
                heading: 0
            };
            const viewerDiv = document.getElementById('viewerDiv');
            const view = new itowns.GlobeView(viewerDiv, placement, { webXR: { controllers: true, cameraOnGround: true } });

            // ---- Add XR Button ----
            view.renderer.xr.enabled = true;
            viewerDiv.appendChild(XRButton.createButton(view.renderer, { requiredFeatures: ['local'], optionFeatures: ['depth-sensing'], depthSensing: { usagePreference: ["cpu-optimized", "gpu-optimized"], dataFormatPreference: ["luminance-alpha", "float32"] } }));

            // ---- Add imagery and elevation layers ----
            function addElevationFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                view.addLayer(new itowns.ElevationLayer(config.id, config));
            }
            itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then(config => {
                config.source = new itowns.WMTSSource(config.source);
                view.addLayer(new itowns.ColorLayer('Ortho', config));
            });
            itowns.Fetcher.json('./layers/JSONLayers/IGN_MNT_HIGHRES.json').then(addElevationFromConfig);
            itowns.Fetcher.json('./layers/JSONLayers/WORLD_DTM.json').then(addElevationFromConfig);

            // ---- Add WFS buildings layers ----
            const wfsBuildingSource = new itowns.WFSSource({
                url: 'https://data.geopf.fr/wfs/ows?',
                version: '2.0.0',
                typeName: 'BDTOPO_V3:batiment',
                crs: 'EPSG:4326',
                ipr: 'IGN',
                format: 'application/json'
            });
            function getBuildingColor(props) {
                const usageMap = {
                    'RÃ©sidentiel': 0xFDFDFF,
                    'Annexe': 0xC6C5B9,
                    'Commercial et services': 0x62929E,
                    'Religieux': 0x393D3F,
                    'Sportif': 0x546A7B
                };
                return new itowns.THREE.Color(usageMap[props.usage_1] || 0x555555);
            }
            function altitudeBuildings(props) { return props.altitude_minimale_sol; }
            function extrudeBuildings(props) { return props.hauteur; }
            function acceptFeature(props) { return !!props.hauteur; }

            // Add wireframe and filled buildings layers
            const wfsWire = new itowns.FeatureGeometryLayer('WFS Building Wireframe', {
                batchId: (_, id) => id,
                filter: acceptFeature,
                source: wfsBuildingSource,
                zoom: { min: 14 },
                style: { fill: { color: new THREE.Color(0x000000), base_altitude: altitudeBuildings, extrusion_height: extrudeBuildings } }
            });
            // wfsWire.wireframe = true;
            // view.addLayer(wfsWire);

            const wfsFilled = new itowns.FeatureGeometryLayer('WFS Building', {
                batchId: (_, id) => id,
                filter: acceptFeature,
                source: wfsBuildingSource,
                zoom: { min: 14 },
                style: {
                    fill: {
                        color: getBuildingColor,
                        opacity: 0.2,
                        base_altitude: altitudeBuildings,
                        extrusion_height: extrudeBuildings
                    }
                }
            });
            view.addLayer(wfsFilled);

            // UI information
            // function updateGNSSStatus() {
            //     document.getElementById('info').innerHTML =
            //         `<li><b>TCP server status:</b> ${TCP_status}</li>
            //         <li><b>Long:</b> ${geo.longitude}</li>
            //         <li><b>Lat:</b> ${geo.latitude}</li>
            //         <li><b>Heading:</b> ${rotation.heading}</li>
            //         <li><b>Pitch:</b> ${rotation.pitch}</li>`;
            // }
            itowns.updateGNSSStatus(TCP_status, geo, rotation);

            // Building picking / info
            function displayProperties(properties) {
                const htmlInfo = document.getElementById('info');
                htmlInfo.innerHTML = '';
                Object.entries(properties)
                    .filter(([k, v]) => v && !k.startsWith('_') && k !== 'geometry_name')
                    .forEach(([k, v]) => {
                        htmlInfo.innerHTML += `<li><b>${k}:</b> ${v}</li>`;
                    });
            }
            
            // Picking function if needed (could be expanded)
            function buildingPicking(event) {
                if (!view.controls.isPaused) return;
                const intersects = view.pickObjectsAt(event, 3, 'WFS Building');
                if (intersects.length) {
                    const intersect = intersects[0];
                    const batchId = intersect.object.geometry.attributes.batchId.array[intersect.face.a];
                    const feature = intersect.object.feature;
                    const properties = feature.geometries[batchId].properties;
                    displayProperties(properties);
                }
            }

            //setup rotation
            const camera = view.camera.camera3D;
            let pitchRad = THREE.MathUtils.degToRad(rotation.pitch);
            let headingRad = THREE.MathUtils.degToRad(rotation.heading);

            camera.rotation.y = headingRad;
            camera.updateMatrixWorld();


            // view.scene.add(new THREE.AmbientLight(0x404040));

            // ---- XR Session: Add buttons and controllers ----
            itowns.setupXRCalibrationUI(view, createText, rotationGlobal);

            // Add event listeners for picking, etc.
            // view.getLayers().find(l => l.id === 'WFS Building')?.whenReady.then(() => {
            //     window.addEventListener('mousemove', buildingPicking, false);
            // });
        }

        //---------------------------
        // Run main
        //---------------------------
        main();
    </script>
</body>

</html>
