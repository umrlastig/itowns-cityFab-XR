<!DOCTYPE html>
<html>

<head>
    <title>iTowns XR Example</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="css/example.css">
    <!-- Import iTowns -->
    <script src="../dist/itowns.js"></script>
    <script src="../dist/debug.js"></script>
    <script src="js/xrCalibration.js"></script>
    <script src="js/utils.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="viewerDiv"></div>
    <div id="description">
        <p><b>GNSS master</b></p>
        <ul id="info"></ul>
    </div>
    <script type="module">

        import * as THREE from 'three';
        import { XRButton } from 'three/addons/webxr/XRButton.js';
        import { createText } from 'three/addons/webxr/Text2D.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        // import placeObjectOnGround from './../../packages/Main/src/Utils/placeObjectOnGround.js';

        // -------------------- Config & Constants --------------------
        const DEFAULT_POSITION = {
            gouaix: { longitude: 3.294129, latitude: 48.483560 },
            mlv: { longitude: 2.587640, latitude: 48.840638 },
            smd: { longitude: 2.4223264, latitude: 48.8447549 },
            loos: { longitude: 2.7922434, latitude: 50.4577818 },
        };

        let rotationGlobal = { pitch: 0, heading: 0, roll: 0 };

        // Utility functions are now imported from ./js/utils.js

        // -------------------- Main Logic --------------------
        async function main() {
            let TCP_status = "Disconnected";
            let geo = DEFAULT_POSITION.mlv;
            let rotation = { pitch: 0, heading: 0, roll: 0 };
            try {
                // const pos = await getCurrentPosition();
                const pos = await fetch('https://localhost:8081/geopos/').then(r => r.json());
                geo = { longitude: pos.longitude, latitude: pos.latitude };
                rotation = { pitch: pos.pitch, heading: pos.heading };
                rotationGlobal = rotation;
                TCP_status = "Connected";
            } catch (e) {
                console.warn("Geolocation error, using default position.", e);
            }

            if (geo.longitude == undefined) {
                geo = DEFAULT_POSITION.mlv;
                TCP_status = "Disconnected";
            }

            // ---- Initialize iTowns view ----
            const placement = {
                coord: new itowns.Coordinates('EPSG:4326', geo.longitude, geo.latitude),
                range: 10,
                tilt: 5,
                heading: 0
            };
            const viewerDiv = document.getElementById('viewerDiv');
            const view = new itowns.GlobeView(viewerDiv, placement, { webXR: { controllers: true, cameraOnGround: true } });

            // ---- Add XR Button ----
            view.renderer.xr.enabled = true;
            viewerDiv.appendChild(XRButton.createButton(view.renderer, { requiredFeatures: ['local'] }));

            // ---- Add imagery and elevation layers ----
            function addElevationFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                view.addLayer(new itowns.ElevationLayer(config.id, config));
            }
            itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then(config => {
                config.source = new itowns.WMTSSource(config.source);
                view.addLayer(new itowns.ColorLayer('Ortho', config));
            });
            itowns.Fetcher.json('./layers/JSONLayers/IGN_MNT_HIGHRES.json').then(addElevationFromConfig);
            itowns.Fetcher.json('./layers/JSONLayers/WORLD_DTM.json').then(addElevationFromConfig);

            // ---- Add WFS buildings layers ----
            const wfsBuildingSource = new itowns.WFSSource({
                url: 'https://data.geopf.fr/wfs/ows?',
                version: '2.0.0',
                typeName: 'BDTOPO_V3:batiment',
                crs: 'EPSG:4326',
                ipr: 'IGN',
                format: 'application/json'
            });
            function getBuildingColor(props) {
                const usageMap = {
                    'RÃ©sidentiel': 0xFDFDFF,
                    'Annexe': 0xC6C5B9,
                    'Commercial et services': 0x62929E,
                    'Religieux': 0x393D3F,
                    'Sportif': 0x546A7B
                };
                return new itowns.THREE.Color(usageMap[props.usage_1] || 0x555555);
            }
            function altitudeBuildings(props) { return props.altitude_minimale_sol; }
            function extrudeBuildings(props) { return props.hauteur; }
            function acceptFeature(props) { return !!props.hauteur; }

            // Add wireframe and filled buildings layers
            const wfsWire = new itowns.FeatureGeometryLayer('WFS Building Wireframe', {
                batchId: (_, id) => id,
                filter: acceptFeature,
                source: wfsBuildingSource,
                zoom: { min: 14 },
                style: { fill: { color: new THREE.Color(0x000000), base_altitude: altitudeBuildings, extrusion_height: extrudeBuildings } }
            });
            // wfsWire.wireframe = true;
            // view.addLayer(wfsWire);

            const wfsFilled = new itowns.FeatureGeometryLayer('WFS Building', {
                batchId: (_, id) => id,
                filter: acceptFeature,
                source: wfsBuildingSource,
                zoom: { min: 14 },
                style: {
                    fill: {
                        color: getBuildingColor,
                        opacity: 0.2,
                        base_altitude: altitudeBuildings,
                        extrusion_height: extrudeBuildings
                    }
                }
            });
            view.addLayer(wfsFilled);

            // UI information
            function updateGNSSStatus() {
                document.getElementById('info').innerHTML =
                    `<li><b>TCP server status:</b> ${TCP_status}</li>
                    <li><b>Long:</b> ${geo.longitude}</li>
                    <li><b>Lat:</b> ${geo.latitude}</li>
                    <li><b>Heading:</b> ${rotation.heading}</li>
                    <li><b>Pitch:</b> ${rotation.pitch}</li>`;
            }
            updateGNSSStatus();

            // Building picking / info
            function displayProperties(properties) {
                const htmlInfo = document.getElementById('info');
                htmlInfo.innerHTML = '';
                Object.entries(properties)
                    .filter(([k, v]) => v && !k.startsWith('_') && k !== 'geometry_name')
                    .forEach(([k, v]) => {
                        htmlInfo.innerHTML += `<li><b>${k}:</b> ${v}</li>`;
                    });
            }
            
            // Picking function if needed (could be expanded)
            function buildingPicking(event) {
                if (!view.controls.isPaused) return;
                const intersects = view.pickObjectsAt(event, 3, 'WFS Building');
                if (intersects.length) {
                    const intersect = intersects[0];
                    const batchId = intersect.object.geometry.attributes.batchId.array[intersect.face.a];
                    const feature = intersect.object.feature;
                    const properties = feature.geometries[batchId].properties;
                    displayProperties(properties);
                }
            }

            //setup rotation
            const camera = view.camera.camera3D;
            let pitchRad = THREE.MathUtils.degToRad(rotation.pitch);
            let headingRad = THREE.MathUtils.degToRad(rotation.heading);

            camera.rotation.y = headingRad;
            camera.updateMatrixWorld();

            // ---- Load 3D model ----
            const mtlLoader = new MTLLoader().setPath('obj/');
            const materials = await mtlLoader.loadAsync('LEG-city_hall.mtl');
            materials.preload();
            const objLoader = new OBJLoader().setPath('obj/');
            objLoader.setMaterials(materials);
            const object = await objLoader.loadAsync('LEG-city_hall.obj');
            object.position.set(view.camera.camera3D.position.x, view.camera.camera3D.position.y + 60, view.camera.camera3D.position.z + 28);
            object.quaternion.copy(view.camera.camera3D.quaternion);
            itowns.DEMUtils.placeObjectOnGround(view.tileLayer, 'EPSG:4978', object);
            object.updateMatrixWorld();
            const pointLight = new THREE.PointLight(0xffffff, 500);
            object.add(pointLight);
            view.scene.add(object);
            view.scene.add(new THREE.AmbientLight(0x404040));

            // ---- XR Session: Add buttons and controllers ----
            setupXRCalibrationUI(view, createText, rotationGlobal);

            // Add event listeners for picking, etc.
            // view.getLayers().find(l => l.id === 'WFS Building')?.whenReady.then(() => {
            //     window.addEventListener('mousemove', buildingPicking, false);
            // });
        }

    // -------------------- XR UI & Calibration Logic --------------------
    // function setupXRCalibrationUI(view) {
    //         const xr = view.renderer.xr;
    //         xr.addEventListener('sessionstart', function () {
    //             const vrControls = view.webXR.vrControls;
    //             let called = false;

    //             // Prepare mesh creation once
    //             const gnssRotationButton = makeButtonMesh(0.2, 0.1, 0.01, 0xffff00, 'gnssRotationButton', 'Gnss');
    //             const buildingsButton = makeButtonMesh(0.3, 0.1, 0.01, 0x008000, 'buildingsButton', 'Buildings');
    //             const titleText = createText('Calibration mode', 0.06);

    //             //prepare guizmos
    //             const groupGuizmo = new THREE.Group();

    //             const geometryLineX = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(5, 0, 0)]);
    //             const geometryLineY = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 5, 0)]);
    //             const geometryLineZ = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 5)]);

    //             const materialLine = new THREE.LineBasicMaterial({ color:  0xFF0000 });//red
    //             const materialLineY = new THREE.LineBasicMaterial({ color: 0x00FF00 });//green
    //             const materialLineZ = new THREE.LineBasicMaterial({ color: 0x0000FF });//blue
    //             const lineX = new THREE.Line(geometryLineX, materialLine);
    //             const lineY = new THREE.Line(geometryLineY, materialLineY);
    //             const lineZ = new THREE.Line(geometryLineZ, materialLineZ);

    //             groupGuizmo.add(lineX);
    //             groupGuizmo.add(lineY);
    //             groupGuizmo.add(lineZ);
    //             view.scene.add(groupGuizmo);
    //             const guizmosGnss = groupGuizmo.clone();
    //             view.scene.add(guizmosGnss);

    //             // Controller 0: highlight buttons based on pointing
    //             this.getController(0).addEventListener('connected', () => {

    //                 let indexRight, indexLeft;
    //                 if (this.getController(0).name == 'left'){
    //                     indexLeft = 0; indexRight = 1;
    //                 } else {
    //                     indexLeft = 1; indexRight = 0;
    //                 }
    //                 const controllerRight = this.getController(indexRight);
    //                 function highlightButton() { 
    //                     let line;
    //                     controllerRight.children.forEach(element => {
    //                         if (element.isLine){
    //                             line = element;
    //                         }
    //                     });

    //                     const raycaster = new THREE.Raycaster();
    //                     const pos = new THREE.Vector3();
    //                     const dir = new THREE.Vector3();

    //                     if (line){
    //                         line.getWorldPosition(pos);
    //                         line.getWorldDirection(dir);

    //                         raycaster.ray.origin = pos;
    //                         raycaster.ray.direction = dir.multiplyScalar(-1);

    //                         // calculate objects intersecting the picking ray
    //                         const intersects = raycaster.intersectObjects(view.scene.children);
    //                         if (intersects.length > 0 && intersects[0].object.name == 'buildingsButton') {
    //                             buildingsButton.material = new THREE.MeshBasicMaterial({ color: 0x025C02 });
    //                         }  else if (intersects.length > 0 && intersects[0].object.name == 'gnssRotationButton') {
    //                             gnssRotationButton.material = new THREE.MeshBasicMaterial({ color: 0xC9C904 });
    //                         }
    //                         else{
    //                             buildingsButton.material = new THREE.MeshBasicMaterial({ color: 0x008000 });
    //                             gnssRotationButton.material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    //                         }
    //                         view.notifyChange();
    //                     } 
    //                  }
    //                 // view.addFrameRequester(itowns.MAIN_LOOP_EVENTS.BEFORE_RENDER, highlightButton);
    //             });

    //             // Controller 1: add buttons and handle press
    //             this.getController(1).addEventListener('connected', () => {
    //                 let indexRight, indexLeft;
    //                 if (this.getController(0).name == 'left'){
    //                     indexLeft = 0; indexRight = 1;
    //                 } else {
    //                     indexLeft = 1; indexRight = 0;
    //                 }
    //                 gnssRotationButton.position.set(-0.15, 0.2, 0);
    //                 buildingsButton.position.set(0.15, 0.2, 0);
    //                 titleText.position.set(0, 0.3, 0);
    //                 [gnssRotationButton, buildingsButton, titleText].forEach(obj => {
    //                     view.scene.add(obj);
    //                     this.getController(indexLeft).add(obj);
    //                 });

    //                 groupGuizmo.position.set(vrControls.groupXR.clone().position.x, vrControls.groupXR.clone().position.y, vrControls.groupXR.clone().position.z);
    //                 groupGuizmo.updateMatrixWorld();
    //                 guizmosGnss.position.set(vrControls.groupXR.clone().position.x, vrControls.groupXR.clone().position.y + 5.5, vrControls.groupXR.clone().position.z);
    //                 guizmosGnss.updateMatrixWorld();
    //                 updateGuizmoPosition();
    //             });

    //             // Handle calibration modes
    //             function initBuildingsMode() {
    //                 vrControls.onRightButtonPressed = function() {};// apply only once initBuildingMode      
    //                 console.log('Buildings mode');             
    //                 gnssRotationButton.visible = false;
    //                 buildingsButton.visible = false;
    //                 titleText.visible = false;
    //                 const text = createText('Buildings mode : use right gamepad to move scene and left gamepad to rotate', 0.03);
    //                 text.position.set(0.2, 0.2, 0);

    //                 const controllerLeft = vrControls.controllers.filter( (controller) => controller.name == 'left')[0];
    //                 controllerLeft.add(text); 

    //                 // End buildings calibration
    //                 vrControls.onLeftButtonPressed = function(evt) {
    //                     [text].forEach(obj => {
    //                         obj.geometry.dispose();
    //                         obj.material.dispose();
    //                         obj.visible = false;
    //                         obj.parent.remove(obj);
    //                     });

    //                     view.notifyChange();
    //                     startDemo();
    //                 };
    //             }

    //             function initSunMode() {
    //                 vrControls.onRightButtonPressed = function() {}; //apply only once initSunMode
    //                 console.log('Buildings mode');             

    //                 gnssRotationButton.visible = false;
    //                 buildingsButton.visible = false;
    //                 titleText.visible = false;

    //                 const text = createText('Sun mode : overlay the target on the sun to calibrate the scene', 0.03);
    //                 text.position.set(0.2, 0.2, 0);

    //                 const controllerLeft = vrControls.controllers.filter( (controller) => controller.name == 'left')[0];
    //                 controllerLeft.add(text); 

    //                 const geometry = new THREE.SphereGeometry(15, 32, 16); 
    //                 const material = new THREE.MeshBasicMaterial({color: 0xffff00}); 
    //                 const sphere = new THREE.Mesh(geometry, material);
    //                 sphere.scale.set(0.01, 0.01, 0.01);
    //                 sphere.position.set(0, 0, -5);
    //                 view.scene.add(sphere);
    //                 view.webXR.vrControls.groupXR.children[0].add(sphere); // follow camera

    //                 // Sun 3D
    //                 const sunPos = view.simulateSun();
    //                 const geometryLine = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 10000)]);
    //                 const materialLine = new THREE.LineBasicMaterial({ color: 0xffff00 }); 
    //                 const line = new THREE.Line(geometryLine, materialLine);
    //                 line.position.set(vrControls.groupXR.clone().position.x, vrControls.groupXR.clone().position.y, vrControls.groupXR.clone().position.z);
    //                 line.lookAt(sunPos);
    //                 line.updateMatrixWorld();
    //                 view.scene.add(line);

    //                 // End sun calibration
    //                 vrControls.onLeftButtonPressed = function(evt) {
    //                     [line, sphere, text].forEach(obj => {
    //                         obj.geometry.dispose();
    //                         obj.material.dispose();
    //                         obj.parent.remove(obj);
    //                     });

    //                     view.notifyChange();
    //                     startDemo();
    //                 };

    //                 // vrControls.onLeftButtonPressed = function(evt) {
    //                 //     const trans = vrControls.groupXR.position.clone();
    //                 //     let offsetRotation;

    //                 //     //  Only apply rotation on 1 axis at the time
    //                 //     offsetRotation = vrControls.getRotationYaw(0.5);
    //                 //     vrControls.applyTransformationToXR(trans, offsetRotation); // Yaw rotation only
    //                 // }

    //                 // vrControls.onRightButtonPressed = function(evt) {
    //                 //     const trans = vrControls.groupXR.position.clone();
    //                 //     let offsetRotation;

    //                 //     //  Only apply rotation on 1 axis at the time
    //                 //     offsetRotation = vrControls.getRotationYaw(0.5);
    //                 //     vrControls.applyTransformationToXR(trans, offsetRotation); // Yaw rotation only
    //                 // }
    //             }

    //             function updateGuizmoPosition() {
    //                     let headingRad = THREE.MathUtils.degToRad(rotationGlobal.heading);
    //                     let pitchRad = THREE.MathUtils.degToRad(0);

    //                     console.log('Update guizmo rotation', rotationGlobal);

    //                     // let headingRad = THREE.MathUtils.degToRad(rotationGlobal.heading);
    //                     const groupXR = view.webXR.vrControls.groupXR;
    //                     const vrControls = view.webXR.vrControls;

    //                     // --- Heading rotation ---
    //                     const upAxis = groupXR.position.clone().normalize();
    //                     // Create a quaternion representing a heading rotation about the up axis.
    //                     const headingQuaternion = new THREE.Quaternion()
    //                         .setFromAxisAngle(upAxis, headingRad)
    //                         .normalize();
    //                     // Apply the heading rotation.
    //                     guizmosGnss.quaternion.copy(headingQuaternion);
    //                     // groupXR.quaternion.premultiply(headingQuaternion);
    //                     groupXR.updateMatrixWorld();

    //                     // --- Pitch rotation ---
    //                     const baseOrientation = groupXR.quaternion.clone().normalize();

    //                     // (Assuming (1, 0, 0) is the right direction in local space.)
    //                     const rightAxis = new THREE.Vector3(1, 0, 0)
    //                         .applyQuaternion(baseOrientation)
    //                         .normalize();

    //                     // Create a quaternion representing a pitch rotation about the right axis.
    //                     const pitchQuaternion = new THREE.Quaternion()
    //                         .setFromAxisAngle(rightAxis, pitchRad)
    //                         .normalize();

    //                     guizmosGnss.quaternion.premultiply(pitchQuaternion);
    //                     groupXR.quaternion.premultiply(pitchQuaternion);
    //                     groupXR.updateMatrixWorld();

    //                     guizmosGnss.updateMatrixWorld();
    //                     view.notifyChange();
    //             }

    //             async function rotateWithGNSS() {
    //                 if (called) return;
    //                 called = true;
    //                 try {
    //                     const pos = await fetch('https://localhost:8081/geopos/').then(r => r.json());
    //                     let headingRad = THREE.MathUtils.degToRad(pos.heading);
    //                     let pitchRad = THREE.MathUtils.degToRad(pos.pitch);

    //                     console.log('Update guizmo rotation', pos.heading);

    //                     // let headingRad = THREE.MathUtils.degToRad(rotationGlobal.heading);
    //                     const groupXR = view.webXR.vrControls.groupXR;
    //                     const vrControls = view.webXR.vrControls;

    //                     // --- Heading rotation ---
    //                     // const upAxis = groupXR.position.clone().normalize();
    //                     const upAxis = new THREE.Vector3(0, -1, 0);
    //                     // Create a quaternion representing a heading rotation about the up axis.
    //                     const headingQuaternion = new THREE.Quaternion()
    //                         .setFromAxisAngle(upAxis, headingRad)
    //                         .normalize();
    //                     // Apply the heading rotation.
    //                     groupXR.quaternion.copy(headingQuaternion);
    //                     // groupXR.quaternion.premultiply(headingQuaternion);

    //                     // groupXR.quaternion.setFromAxisAngle(upAxis, headingRad);


    //                     // --- Pitch rotation ---
    //                     const baseOrientation = groupXR.quaternion.clone().normalize();

    //                     // (Assuming (1, 0, 0) is the right direction in local space.)
    //                     const rightAxis = new THREE.Vector3(0, 0, 1)
    //                         .applyQuaternion(baseOrientation)
    //                         .normalize();

    //                     // Create a quaternion representing a pitch rotation about the right axis.
    //                     const pitchQuaternion = new THREE.Quaternion()
    //                         .setFromAxisAngle(rightAxis, pitchRad)
    //                         .normalize();

    //                     groupXR.quaternion.premultiply(headingQuaternion);
    //                     groupXR.quaternion.premultiply(pitchQuaternion);
    //                     // groupXR.quaternion.setFromAxisAngle(rightAxis, pitchRad);

    //                     groupXR.updateMatrixWorld();

    //                     guizmosGnss.updateMatrixWorld();
    //                     view.notifyChange();
                       
    //                 } catch (e) {
    //                     console.warn("Geolocation error, using default position.", e);
    //                 }
    //             }


    //             function startDemo(){
    //                 vrControls.onLeftAxisChanged = function(){};
    //                 vrControls.onRightAxisChanged = function(){};
    //                 vrControls.onLeftButtonPressed = function(){};

    //                 const text = createText('Demonstration session', 0.03);
    //                 text.position.set(0.2, 0.2, 0);
    //                 view.webXR.vrControls.controllers[1].add(text);

    //                 console.log('Begin demo'); 

    //                 vrControls.onRightButtonPressed = function(){
    //                     // Building picking / info
    //                     function displayProperties(properties) {
    //                         const htmlInfo = document.getElementById('info');
    //                         htmlInfo.innerHTML = '';
    //                         Object.entries(properties)
    //                             .filter(([k, v]) => v && !k.startsWith('_') && k !== 'geometry_name')
    //                             .forEach(([k, v]) => {
    //                                 htmlInfo.innerHTML += `<li><b>${k}:</b> ${v}</li>`;
    //                             });
    //                     }

    //                     let line;
    //                     const controllerRight = this.getController(0);
    //                     controllerRight.children.forEach(element => {
    //                         if (element.isLine){
    //                             line = element;
    //                         }
    //                     });

    //                     const raycaster = new THREE.Raycaster();
    //                     const pos = new THREE.Vector3();
    //                     const dir = new THREE.Vector3();

    //                     if (line){
    //                         line.getWorldPosition(pos);
    //                         line.getWorldDirection(dir);

    //                         raycaster.ray.origin = pos;
    //                         raycaster.ray.direction = dir.multiplyScalar(-1);

    //                         // calculate objects intersecting the picking ray
    //                         const intersects = raycaster.intersectObjects(view.scene.children);
    //                         if (intersects.length > 0 && intersects[0].object.name == 'WFS Building') {
    //                             const intersect = intersects[0];
    //                             const batchId = intersect.object.geometry.attributes.batchId.array[intersect.face.a];
    //                             const feature = intersect.object.feature;
    //                             const properties = feature.geometries[batchId].properties;
    //                             // displayProperties(properties);
        
    //                         }  

    //                     } 

    //                     // Picking function if needed (could be expanded)
    //                     function buildingPicking(event) {
    //                         if (!view.controls.isPaused) return;
    //                         const intersects = view.pickObjectsAt(event, 3, 'WFS Building');
    //                         if (intersects.length) {
    //                             const intersect = intersects[0];
    //                             const batchId = intersect.object.geometry.attributes.batchId.array[intersect.face.a];
    //                             const feature = intersect.object.feature;
    //                             const properties = feature.geometries[batchId].properties;
    //                             displayProperties(properties);
    //                         }
    //                     }
    //                 };
    //             }

    //             vrControls.onRightButtonPressed = function(evt) { 
    //                 called = false;

    //                 // select button
    //                 const controllerRight = this.controllers.filter( (controller) => controller.name == 'right')[0];
                    
    //                 let line;
    //                 controllerRight.children.forEach(element => {element.isLine ? line = element : console.warn('No line in controler') });

    //                 const raycaster = new THREE.Raycaster();
    //                 const pos = new THREE.Vector3();
    //                 const dir = new THREE.Vector3();

    //                 if (line){
    //                     line.getWorldPosition(pos);
    //                     line.getWorldDirection(dir);

    //                     raycaster.ray.origin = pos;
    //                     raycaster.ray.direction = dir.multiplyScalar(-1);

    //                     // calculate objects intersecting the picking ray
    //                     const intersects = raycaster.intersectObjects(view.scene.children);
    //                     if (intersects.length > 0 && intersects[0].object.name == 'buildingsButton') {
    //                         initBuildingsMode(); // buildings mode calibration
    //                         view.notifyChange();
    //                     } else if (intersects.length > 0 && intersects[0].object.name == 'gnssRotationButton') {
    //                         // initSunMode(); // sun mode calibration
    //                         called = false;
    //                         rotateWithGNSS();
    //                         // updateGuizmoPosition();
    //                         view.notifyChange();
    //                     }
    //                 }
    //              };

    //             vrControls.onLeftButtonPressed = function(evt) {
                    
    //                 function findMeshinChildren(featureMesh) {
    //                     const children = featureMesh.children[0];
    //                     if (children.isMesh) {
    //                         const material = new THREE.MeshBasicMaterial({ color: children.material.color });
    //                         material.transparent = true;
    //                         material.opacity = 0.5;
    //                         material.blending = THREE.CustomBlending;
    //                         material.blendEquation = THREE.SubtractEquation;
    //                         material.blendSrc = THREE.SrcAlphaFactor;
    //                         material.blendDst = THREE.ZeroFactor;
    //                         // src https://threejs.org/examples/?q=blending#webgl_materials_blending_custom
    //                         children.material = material;
    //                     } else {
    //                         findMeshinChildren(children);
    //                     }
    //                 }

    //                 this.view.renderer.setClearColor(new THREE.Color(), 0);
    //                 this.view.tileLayer.opacity = 0;

    //                 // Add the event listener only once when the layer is ready
    //                 const layer = this.view.getLayers().find(l => l.id === 'WFS Building');
    //                 if (layer) {
    //                     layer.whenReady.then(() => {
    //                         layer.object3d.children.forEach((featureMesh) => {
    //                             findMeshinChildren(featureMesh);
    //                             this.view.notifyChange();
    //                         });
    //                     });
    //                 }
    //                 this.view.notifyChange();
    //              };
    //         });
    //     }

        //---------------------------
        // Run main
        //---------------------------
        main();
    </script>
</body>

</html>
